@parser;
	main: statement*;
	statement: import | set | print | while | return | comment | fn | new | expression;
	comment: lexer.comment;
	import: ~'import' string (~'as' string)? ~'from' string;
	while: ~'while' expression ~'(' statement* ~')';
	print: ~'print' ~':' expression;
	set: ~'set' identifier pointerRight expression;
	return: ~'return' ~':' (expression | statement)?;
	expression: equality;
	call: ~'(' (expression (~',' expression)*)? ~')';
	equality: comparison (('!=' | '=') comparison)*;
	comparison: additive (('<=' | '>=' | '<' | '>') additive)*;
	additive: multiplicative (('+' | '-') multiplicative)*;
	multiplicative: prefix (('*' | '/' | '%') prefix)*;
	prefix: ('+' | '-')* postfix;
	postfix: atom call*;
	atom: new | number | string | identifier | boolean | ~'(' expression ~')';
	fn: ~'fn' identifier arguments ~'(' statement* ~')';
	new: ~'new' identifier arguments;
	arguments: ~'(' (identifier (~',' identifier)*)? ~')';

@lexer;
	set: 'set';
	print: 'print';
	while: 'while';
	return: 'return';
	import: 'import';
	new: 'new';
	fn: 'fn';
	as: 'as';
	from: 'from';
	boolean: 'true' | 'false';
	comment: /<<[^]*?>>/;
	string: /"(?:[^"\\]|\\["\\])*"/ | /'(?:[^'\\]|\\['\\])*'/;
	pointerRight: '->';
	pointerLeft: '<-';
	lteq: '<=';
	gteq: '>=';
	neq: '!=';
	eq: '=';
	add: '+';
	subtract: '-';
	multiply: '*';
	divide: '/';
	modulo: '%';
	lt: '<';
	gt: '>';
	colon: ':';
	lparen: '(';
	rparen: ')';
	comma: ',';
	identifier: /[a-zA-Z]+/;
	number: /[0-9]+/ ('.' /[0-9]+/)?;
	_whitespace: /\s+/;